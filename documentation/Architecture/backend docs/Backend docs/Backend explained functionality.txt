===DESCRIPTION
The main functionality provided by backend is parsing the natural language text to json representation of @@@JsonResponseSchema so that the frontend will be able to easily convert that response to UI functionality. This conversions is based both on used properties added to objects and also default values if none were supplied. The default values were obtained from the @@@Antology instances. Other functionality provided by backend is sending default videos, audios and images.

===Default API functionality
One of the routes is /audio which has an query argument seconds. By using the values of this query argument we will be able to obtain an mp3 audio file between 1 and 168 seconds. Another route is /video which is very similar to audio, because it has the same query parameter seconds and returns a video having the length of the specified argument and the file type is mp4. Last one is /image which has an query argument type which can take three values [default, profile, button] which of course are returned when the user does not provide these values of images.

===Used libraries for main functionality
The backend API was all written in ###Python. Between the external libraries used we have ###Flask, ###Moviepy and ###rdflib. Flask was used for providing the routes and return data because it can be used easily and has great extensibility. The routher provided by flask are /audio, /video, /image, /language. MoviePy was used to crop the video file to the specified length. No other usage in the project. Rdflib was used for querying instances from the database in case when calling /language route, objects did not have all properties set. So, default entities were created and from them these values will be selected.

===Explain route /language
As explained already above, this route will translate the text natural language constructed using the @@@language constructs, to the @@@JsonResponseSchema. The request will be a post having respecting @@@JsonRequestSchema. Why the request is that simple? Because it only needs the text from the user and all the necessary functionality will be handled by the backend.

Explaining the flow of the backend from a overview point, when we call the route the application sends the data to a @@@LanguageParser instance. This instance will return at the end the result as a json. It tries to split the text by already knows components and afterwords validates the existing components if they respect the criteria from the @@@language. After that every element is parsed by their type, so every element will have a dedicated parser. The result is then transformed into Entity class. Inside the entity class, we have a mechanism which will find all the not specified properties and query the antology for default values. Of course even at this part, we have specific query for every component. At the end the result data are agregated and returned. $$$IMAGE=Backend FLOW DIAGRAM

===Entities
Available values for entities properties were added to a data class named AvailableProperties. All entities will extend a base class named BaseEntity which has 2 properties, available properties, explained before and baseEntityQuery, see in next section. Also, this class has an abstract method toJson, which should return a json representation of the object. Every one of these objects have different properties and one most commonly used is TextProperties, which is another entity class. This entities are strongly coupled BaseEntityQuery. The flow is as follows: we create the object and before finishing the creation, inside the constructor, we query the antology for default values, combine the result and the transform the object to json @@@JsonResponseSchema. These entities are separated in two categories: compositional objects and structural ones. These distinction was made because the compositional elements are end element which mainly do not contain other elements in them whereas structural ones do contain more compositional elements inside them. Between compositional object we have: Image, Video, Alert, Audio, PhotoGallery, Button, Paragraph, Heading, Profile, Input, Link, Slider, Calender and TextProperties. Structural elements are: List, Header, Navbar, Table, Footer, Aside.


===SPARQL Queries
As explained above, sparql queries were used to obtain default values from the default instances in the antology. For obtaining this data, two helper classes were created (QueryExecutor, GenericQuery). First one is used for more complex queries which cannot be easily done in a generic setup, when the second one is used for generic queries which can be easily implemented on a key, keyToProp base. What I mean by key, keyToProp base is that, for every missing key, we have a specific part of the query which can be easily added to the map with the name of the key. In some cases, this is not possible because of the need of nested object, for example TextProperties, where Query executor will be used. These helper clases will be used in specific query classes based on the object type. All classes with extend the functionaliy of the BaseEntityQeury class having an execute method with required argument keys and a map from key (meaning object properties) to part of the sparql query that will extract data. Between these classes we have: QuerySlider, QueryImage, QueryCalendar, QueryAlert, QueryAudio, QueryButton, QueryVideo, QueryHeader, QueryPhotoGallery, QueryList, QueryTable, QueryMain, QueryFooter, QueryAside, QueryNavba, QueryParagraph, QueryHeading, QueryInput, QueryProfile, QueryLink. 


===Language Parsers
The top level class responsible of handling the the parsing of the given text is the LanguageParser, which will separate text by known structural entities, and valitate that the text respects the requiments added in the @@@Language. Of course, there is a big difference between parsing compositional elements and structural ones. As compositional are end level, they do not need further parsing whereas strutural ones, need also a parsing on the element level. So, by parsing structural elements, we also then parse inside this be compositional ones. So then a new class will be needed, named ElementParser which will parse this compositional elements by their known text representation. This class will provide a switch functionality of selecting the correct parser for each element. Between these parsers we have: ParseAlert, ParseAudio, ParseButton, ParseCalendar, ParseHeading, ParseImage, ParseInput, ParseParagraph, ParsePhotoGallery, ParseNavbar, ParseMain, ParseList, parseFooter, ParseHeader, PArseAside, ParseVideo, ParseUserProfile, ParseSlider, ParseTable.

===Flask HTTP APP
The flask application will be responsabile of redirecting the request to their solving implementations. So mainly speaking of /language route. If the flow is correct, an success response of @@@JSONResponse schema is send. If not, then if the error is a know one, it is returned and if possible the position where it does occur. If the error is not know, then a generic error message is send and an a recommandation to visit the @@@Language docs to better understand how to write the query data. See befow image to better understand the backend components.
$$$IMAGE=Class Diagram

===Language constructs
For a easier modeling process, a description language on which the UI response will be shows was created. The following sections will explain it in detail and also which examples regarding any posible elements and its available properties. Also, to remember that, even in this language, the components are separated into the know categories: compositional, structural.

!!! ADD ALL language components

===Backend response schema
The responses returned by the /language api are in json format and have the following structure. The first, status property states wheter or not an error has occured. Of course, ERROR means an error occured and SUCCCES mean the FRONTEND can parse it to create the interface. Both of them have then, and response object, which has different construction in each case. In case of error, ERROR_REASON states why the error occured and the positionInText states where the error occured. If the error is not a predefined one, then an generic error message is returned and positionInText states that it is not available. The success reponse, then contains a list of sections. This list of sections respect the @@@Language requirements. And this list is a uppercase list containing the names of all available sections in the UI. After that, each available structural sections is added with their properties and their list of elements. See below explained schema for a better understanding of how these json representation look like.

===Call /language API examples
This section ilustrates the returned by the API for almost all available components. This is the exact values returned by the API.

===Default values
Here is a list of default values used fost components. Of course, these values can be better seen inside the antology.

===Antology
The antology was created exactly for mapping existing components properties. At top level, under owl:Thing, we have TextualElement and WebElement. Textual Element is a more abtract class which refers to text and its properties: font color, size, style, decoration. Under this we have Label, Text and Username, which are different entities, and also have different constraints. For example, Username string value must be between 3 and 16 characters, text can have any length, and label must have at most 128 characters. Moving to WebElement, it is a generic object which contains properties hold by all elements. As an child of this, we have the well known CompositionalElement and StructuralElement classes. In addition, here is also present the alert element as it cannot be considered of any of the other types. Now, looking at compositionalElement, we again seperate it into TextBasedElements, which refer to elements that are mainly based on text and NonTextBasedElements. Between TextBasedElements we have: Heading, Paragraph, Link, TextInput, SearchInput. Between NonTextBasedElements we have: Video, ZoomSlider, OpacitySlider, Audio, PhotoGallery, Calendar, Image, buttons(Cancel, download, save, edit, submit, reset). Going back to strucural elements, as its child we have: Table, OrderedList and different sections as Main, Footer, Header, NavigationBar, Aside. For a better understanding please see Antology.owl. Also, take a look the the below image about antology.